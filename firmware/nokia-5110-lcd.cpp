#include "nokia-5110-lcd.h"

byte Nokia5110LCD::Display::displayMap[LCD_WIDTH * LCD_HEIGHT / 8] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,0)->(11,7) ~ These 12 bytes cover an 8x12 block in the left corner of the display 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,0)->(23,7)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, // (24,0)->(35,7)
	0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0x1E, 0x0E, 0x02, 0x00, // (36,0)->(47,7)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,0)->(59,7)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,0)->(71,7)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,0)->(83,7)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,8)->(11,15)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,8)->(23,15)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // (24,8)->(35,15)
	0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, // (36,8)->(47,15)
	0xF8, 0xF0, 0xF8, 0xFE, 0xFE, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, // (48,8)->(59,15)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,8)->(71,15)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,8)->(83,15)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,16)->(11,23)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,16)->(23,23)
	0x00, 0x00, 0xF8, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF, 0xF3, 0xE0, 0xE0, 0xC0, // (24,16)->(35,23)
	0xC0, 0xC0, 0xE0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,16)->(47,23)
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0x00, 0x00, 0x00, // (48,16)->(59,23)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,16)->(71,23)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,16)->(83,23)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,24)->(11,31)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,24)->(23,31)
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (24,24)->(35,31)
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,24)->(47,31)
	0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, // (48,24)->(59,31)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,24)->(71,31)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,24)->(83,31)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,32)->(11,39)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,32)->(23,39)
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, // (24,32)->(35,39)
	0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, // (36,32)->(47,39)
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,32)->(59,39)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,32)->(71,39)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,32)->(83,39)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,40)->(11,47)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,40)->(23,47)
	0x00, 0x00, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, // (24,40)->(35,47)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (36,40)->(47,47)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,40)->(59,47)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,40)->(71,47)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,40)->(83,47) !!! The bottom right pixel!
};

byte Nokia5110LCD::Display::ASCII[96][5] = {
	// First 32 characters (0x00-0x19) are ignored. These are
	// non-displayable, control characters.
	 {0x00, 0x00, 0x00, 0x00, 0x00} // 0x20  
	,{0x00, 0x00, 0x5f, 0x00, 0x00} // 0x21 !
	,{0x00, 0x07, 0x00, 0x07, 0x00} // 0x22 "
	,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 0x23 #
	,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 0x24 $
	,{0x23, 0x13, 0x08, 0x64, 0x62} // 0x25 %
	,{0x36, 0x49, 0x55, 0x22, 0x50} // 0x26 &
	,{0x00, 0x05, 0x03, 0x00, 0x00} // 0x27 '
	,{0x00, 0x1c, 0x22, 0x41, 0x00} // 0x28 (
	,{0x00, 0x41, 0x22, 0x1c, 0x00} // 0x29 )
	,{0x14, 0x08, 0x3e, 0x08, 0x14} // 0x2a *
	,{0x08, 0x08, 0x3e, 0x08, 0x08} // 0x2b +
	,{0x00, 0x50, 0x30, 0x00, 0x00} // 0x2c ,
	,{0x08, 0x08, 0x08, 0x08, 0x08} // 0x2d -
	,{0x00, 0x60, 0x60, 0x00, 0x00} // 0x2e .
	,{0x20, 0x10, 0x08, 0x04, 0x02} // 0x2f /
	,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 0x30 0
	,{0x00, 0x42, 0x7f, 0x40, 0x00} // 0x31 1
	,{0x42, 0x61, 0x51, 0x49, 0x46} // 0x32 2
	,{0x21, 0x41, 0x45, 0x4b, 0x31} // 0x33 3
	,{0x18, 0x14, 0x12, 0x7f, 0x10} // 0x34 4
	,{0x27, 0x45, 0x45, 0x45, 0x39} // 0x35 5
	,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 0x36 6
	,{0x01, 0x71, 0x09, 0x05, 0x03} // 0x37 7
	,{0x36, 0x49, 0x49, 0x49, 0x36} // 0x38 8
	,{0x06, 0x49, 0x49, 0x29, 0x1e} // 0x39 9
	,{0x00, 0x36, 0x36, 0x00, 0x00} // 0x3a :
	,{0x00, 0x56, 0x36, 0x00, 0x00} // 0x3b ;
	,{0x08, 0x14, 0x22, 0x41, 0x00} // 0x3c <
	,{0x14, 0x14, 0x14, 0x14, 0x14} // 0x3d =
	,{0x00, 0x41, 0x22, 0x14, 0x08} // 0x3e >
	,{0x02, 0x01, 0x51, 0x09, 0x06} // 0x3f ?
	,{0x32, 0x49, 0x79, 0x41, 0x3e} // 0x40 @
	,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 0x41 A
	,{0x7f, 0x49, 0x49, 0x49, 0x36} // 0x42 B
	,{0x3e, 0x41, 0x41, 0x41, 0x22} // 0x43 C
	,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 0x44 D
	,{0x7f, 0x49, 0x49, 0x49, 0x41} // 0x45 E
	,{0x7f, 0x09, 0x09, 0x09, 0x01} // 0x46 F
	,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 0x47 G
	,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 0x48 H
	,{0x00, 0x41, 0x7f, 0x41, 0x00} // 0x49 I
	,{0x20, 0x40, 0x41, 0x3f, 0x01} // 0x4a J
	,{0x7f, 0x08, 0x14, 0x22, 0x41} // 0x4b K
	,{0x7f, 0x40, 0x40, 0x40, 0x40} // 0x4c L
	,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 0x4d M
	,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 0x4e N
	,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 0x4f O
	,{0x7f, 0x09, 0x09, 0x09, 0x06} // 0x50 P
	,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 0x51 Q
	,{0x7f, 0x09, 0x19, 0x29, 0x46} // 0x52 R
	,{0x46, 0x49, 0x49, 0x49, 0x31} // 0x53 S
	,{0x01, 0x01, 0x7f, 0x01, 0x01} // 0x54 T
	,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 0x55 U
	,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 0x56 V
	,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 0x57 W
	,{0x63, 0x14, 0x08, 0x14, 0x63} // 0x58 X
	,{0x07, 0x08, 0x70, 0x08, 0x07} // 0x59 Y
	,{0x61, 0x51, 0x49, 0x45, 0x43} // 0x5a Z
	,{0x00, 0x7f, 0x41, 0x41, 0x00} // 0x5b [
	,{0x02, 0x04, 0x08, 0x10, 0x20} // 0x5c \
	,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
	,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
	,{0x04, 0x02, 0x01, 0x02, 0x04} // 0x5e ^
	,{0x40, 0x40, 0x40, 0x40, 0x40} // 0x5f _
	,{0x00, 0x01, 0x02, 0x04, 0x00} // 0x60 `
	,{0x20, 0x54, 0x54, 0x54, 0x78} // 0x61 a
	,{0x7f, 0x48, 0x44, 0x44, 0x38} // 0x62 b
	,{0x38, 0x44, 0x44, 0x44, 0x20} // 0x63 c
	,{0x38, 0x44, 0x44, 0x48, 0x7f} // 0x64 d
	,{0x38, 0x54, 0x54, 0x54, 0x18} // 0x65 e
	,{0x08, 0x7e, 0x09, 0x01, 0x02} // 0x66 f
	,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 0x67 g
	,{0x7f, 0x08, 0x04, 0x04, 0x78} // 0x68 h
	,{0x00, 0x44, 0x7d, 0x40, 0x00} // 0x69 i
	,{0x20, 0x40, 0x44, 0x3d, 0x00} // 0x6a j
	,{0x7f, 0x10, 0x28, 0x44, 0x00} // 0x6b k
	,{0x00, 0x41, 0x7f, 0x40, 0x00} // 0x6c l
	,{0x7c, 0x04, 0x18, 0x04, 0x78} // 0x6d m
	,{0x7c, 0x08, 0x04, 0x04, 0x78} // 0x6e n
	,{0x38, 0x44, 0x44, 0x44, 0x38} // 0x6f o
	,{0x7c, 0x14, 0x14, 0x14, 0x08} // 0x70 p
	,{0x08, 0x14, 0x14, 0x18, 0x7c} // 0x71 q
	,{0x7c, 0x08, 0x04, 0x04, 0x08} // 0x72 r
	,{0x48, 0x54, 0x54, 0x54, 0x20} // 0x73 s
	,{0x04, 0x3f, 0x44, 0x40, 0x20} // 0x74 t
	,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 0x75 u
	,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 0x76 v
	,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 0x77 w
	,{0x44, 0x28, 0x10, 0x28, 0x44} // 0x78 x
	,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 0x79 y
	,{0x44, 0x64, 0x54, 0x4c, 0x44} // 0x7a z
	,{0x00, 0x08, 0x36, 0x41, 0x00} // 0x7b {
	,{0x00, 0x00, 0x7f, 0x00, 0x00} // 0x7c |
	,{0x00, 0x41, 0x36, 0x08, 0x00} // 0x7d }
	,{0x10, 0x08, 0x08, 0x10, 0x08} // 0x7e ~
	,{0x78, 0x46, 0x41, 0x46, 0x78} // 0x7f DEL
};

// Constructors
//
// set pins, default x, y, contrast
// Pin definitions: 
// Most of these pins can be moved to any digital or analog pin.
// DN(MOSI)and SCLK should be left where they are (SPI pins). The 
// LED (backlight) pin should remain on a PWM-capable pin.
Nokia5110LCD::Display::Display(int _pinSCE, int _pinRESET, int _pinDC,
			       int _pinBL, int _pinSDIN, int _pinSCLK)
{
	pinSCE 	 = _pinSCE;
	pinRESET = _pinRESET;
	pinDC 	 = _pinDC;
	pinSDIN  = _pinSDIN;
	pinSCLK  = _pinSCLK;
	pinBL 	 = _pinBL;
	lcdX 	 = 84;
	lcdY 	 = 48;
	contrast = 0xB0;
}

Nokia5110LCD::Display::~Display()
{
	
}

// sets up control pins and
// sends magical commands to the PCD8544
void Nokia5110LCD::Display::begin()
{
	// configure control pins
	pinMode(pinSCE, OUTPUT);
	pinMode(pinRESET, OUTPUT);
	pinMode(pinDC, OUTPUT);
	pinMode(pinSDIN, OUTPUT);
	pinMode(pinSCLK, OUTPUT);
	pinMode(pinBL, OUTPUT);
	analogWrite(pinBL, 255);

	SPI.begin();
	SPI.setDataMode(SPI_MODE0);
	SPI.setBitOrder(MSBFIRST);
	
	// reset the LCD to a known state
	digitalWrite(pinRESET, LOW);
	digitalWrite(pinRESET, HIGH);
	
	// tell LCD that extended commands follow
	write(LCD_COMMAND, 0x21);
	// set LCD Vop (Contrast): Try 0xB1(good @ 3.3V) or 0xBF if your display is too dark
	write(LCD_COMMAND, 0xB0);
	// set Temp coefficent
	write(LCD_COMMAND, 0x04);
	// LCD bias mode 1:48: Try 0x13 or 0x14
	write(LCD_COMMAND, 0x14);
	// we must send 0x20 before modifying the display control mode
	write(LCD_COMMAND, 0x20);
	// set display control, normal mode. 0x0D for inverse
	write(LCD_COMMAND, 0x0C);
}

// There are two memory banks in the LCD, data/RAM and commands. This 
// function sets the DC pin high or low depending, and then sends
// the data byte
void Nokia5110LCD::Display::write(byte data_or_command, byte data) {
	//Tell the LCD that we are writing either to data or a command
	digitalWrite(pinDC, data_or_command);
	
	//Send the data
	digitalWrite(pinSCE, LOW);
	SPI.transfer(data); //shiftOut(pinSDIN, pinSCLK, MSBFIRST, data);
	digitalWrite(pinSCE, HIGH);
}

// This function sets a pixel on displayMap to your preferred
// color. 1=Black, 0= white.
void Nokia5110LCD::Display::setPixel(int x, int y, boolean bw) {
	// first, double check that the coordinate is in range.
	if ((x >= 0) && (x < LCD_WIDTH) && (y >= 0) && (y < LCD_HEIGHT)) {
		byte shift = y % 8;

		if (bw) // if black, set the bit
			displayMap[x + (y / 8) * LCD_WIDTH] |= 1 << shift;
		else	// if white clear the bit
			displayMap[x + (y / 8) * LCD_WIDTH] &= ~(1 << shift);
	}
}

void Nokia5110LCD::Display::clearPixel(int x, int y) {
	setPixel(x, y, WHITE); // call setPixel with bw set to white will clear.
}

// setLine draws a line from x0,y0 to x1,y1 with the set color.
// this function was grabbed from the SparkFun ColorLCDShield library
void Nokia5110LCD::Display::setLine(int x0, int y0, int x1, int y1, boolean bw) {
	int dy = y1 - y0;
	int dx = x1 - x0;
	int stepx, stepy;

	if (dy < 0) {
		dy = -dy;
		stepy = -1;
	} else {
		stepy = 1;
	}

	if (dx < 0) {
		dx = -dx;
		stepx = -1;
	} else {
		stepx = 1;
	}

	dy <<= 1; // dy is now 2 * dy
	dx <<= 1; // dx is now 2 * dx
	setPixel(x0, y0, bw); // Draw the first pixel

	if (dx > dy) {
		int fraction = dy - (dx >> 1);
		while (x0 != x1) {
			if (fraction >= 0) {
				y0 += stepy;
				fraction -= dx;
			}
			x0 += stepx;
			fraction += dy;
			setPixel(x0, y0, bw);
		}
	} else {
		int fraction = dx - (dy >> 1);
		while (y0 != y1) {
			if (fraction >= 0) {
				x0 += stepx;
				fraction -= dy;
			}
			y0 += stepy;
			fraction += dx;
			setPixel(x0, y0, bw);
		}
	}
}

// setRect will draw a rectangle from x0,y0 top-left corner to 
// a x1,y1 bottom-right corner. Can be filled with the fill
// parameter, and colored with bw.
// this function was grabbed from the SparkFun ColorLCDShield library
void Nokia5110LCD::Display::setRect(int x0, int y0, int x1, int y1, boolean fill, boolean bw) {
	// check if the rectangle is to be filled
	if (fill == 1) {
		int xDiff;

		if (x0 > x1)
			xDiff = x0 - x1; // find the difference between the x vars
		else
			xDiff = x1 - x0;

		while (xDiff > 0) {
			setLine(x0, y0, x0, y1, bw);

			if (x0 > x1)
				--x0;
			else
				++x0;

			--xDiff;
		}
	} else {
		// best way to draw and unfilled rect is to draw four lines
		setLine(x0, y0, x1, y0, bw);
		setLine(x0, y1, x1, y1, bw);
		setLine(x0, y0, x0, y1, bw);
		setLine(x1, y0, x1, y1, bw);
	}
}

// setCircle draws a circle centered around x0,y0 with a defined
// radius. the circle can be black or white. and have a line
// thickenss ranging from 1 to the radius of the circle.
// this function was grabbed from the SparkFun ColorLCDShield library
void Nokia5110LCD::Display::setCircle(int x0, int y0, int radius, boolean bw, int lineThickness) {
	for (int r = 0; r < lineThickness; r++) {
		int f = 1 - radius;
		int ddF_x = 0;
		int ddF_y = -2 * radius;
		int x = 0;
		int y = radius;

		setPixel(x0, y0 + radius, bw);
		setPixel(x0, y0 - radius, bw);
		setPixel(x0 + radius, y0, bw);
		setPixel(x0 - radius, y0, bw);

		while (x < y) {
			if (f >= 0) {
				--y;
				ddF_y += 2;
				f += ddF_y;
			}
			++x;
			ddF_x += 2;
			f += ddF_x + 1;

			setPixel(x0 + x, y0 + y, bw);
			setPixel(x0 - x, y0 + y, bw);
			setPixel(x0 + x, y0 - y, bw);
			setPixel(x0 - x, y0 - y, bw);
			setPixel(x0 + y, y0 + x, bw);
			setPixel(x0 - y, y0 + x, bw);
			setPixel(x0 + y, y0 - x, bw);
			setPixel(x0 - y, y0 - x, bw);
		}
		--radius;
	}
}

// this function will draw a char (defined in the ASCII table)
// at a defined x and y. the color can be black or white.
void Nokia5110LCD::Display::setChar(char character, int x, int y, boolean bw) {
	byte column; // temp byte to store character's column bitmap
	for (int i = 0; i < 5; i++) { // 5 columns (x) per character
		column = ASCII[character - 0x20][i];
		for (int j = 0; j < 8; j++) { // 8 rows (y) per character
			if (column & (0x01 << j)) // test bits to set pixels
				setPixel(x + i, y + j, bw);
			else
				setPixel(x + i, y + j, !bw);
		}
	}
}

// setStr draws a string of characters, calling setChar with
// progressive coordinates until it's done.
// this function was grabbed from the SparkFun ColorLCDShield library
void Nokia5110LCD::Display::setStr(char * dString, int x, int y, boolean bw) {
	while (*dString != 0x00) { // loop until null terminator
		setChar(*dString++, x, y, bw);
		x += 5;
		for (int i = y; i < (y + 8); i++) {
			setPixel(x, i, !bw);
		}
		++x;
		if (x > (LCD_WIDTH - 5)) { // enables wrap around
			x = 0;
			y += 8;
		}
	}
}

// this function will draw an array over the screen. the array must be
// the same size as the screen, covering the entirety of the display
void Nokia5110LCD::Display::setBitmap(char * bitArray) {
	for (int i = 0; i < (LCD_WIDTH * LCD_HEIGHT / 8); i++) {
		displayMap[i] = bitArray[i];
	}
}

// this function clears the entire display either white or black
// the screen won't actually clear until you call updateDisplay()!
void Nokia5110LCD::Display::clearDisplay(boolean bw) {
	for (int i = 0; i < (LCD_WIDTH * LCD_HEIGHT / 8); i++) {
		if (bw)
			displayMap[i] = 0xFF;
		else
			displayMap[i] = 0;
	}
}

// helpful function to directly command the LCD to go to a
// specifix x, y coordinate
void Nokia5110LCD::Display::gotoXY(int x, int y) {
	write(0, 0x80 | x); // column
	write(0, 0x40 | y); // row
}

// this will actually draw on the display, whatever is currently
// in the displayMap array.
void Nokia5110LCD::Display::updateDisplay() {
	gotoXY(0, 0);
	for (int i = 0; i < (LCD_WIDTH * LCD_HEIGHT / 8); i++) {
		write(LCD_DATA, displayMap[i]);
	}
}

//set contrast can set the CLD Vop to a value between 0 and 127.
// 40 - 60 is usually a pretty good range.
void Nokia5110LCD::Display::setContrast(byte contrast) {
	write(LCD_COMMAND, 0x21); // tell LCD that extended commands to follow
	write(LCD_COMMAND, 0x80 | contrast); // set LCD Vop
	write(LCD_COMMAND, 0x20); // set display mode
}

// there are two ways to do this. either through direct commands
// to the display, or by swapping each bit in the displayMap array.
// we'll leave both methods here, comment one or the other out if
// you please.
void Nokia5110LCD::Display::invertDisplay() {
	// Direct LCD command option
	//write(LCD_COMMAND, 0x20); // extended commnads to follow
	//write(LCD_COMMAND, 0x08 | 0x05);
	//write(LCD_COMMAND, 0x20); // set displaly mode

	// indirect, swap bits in displayMap option:
	for (int i = 0; i < (LCD_WIDTH * LCD_HEIGHT / 8); i++) {
		displayMap[i] = ~displayMap[i] & 0xFF;
	}
	updateDisplay();
}
